# 哨兵 MPC 技术原理详解：从公式到直觉

MPC（模型预测控制）的核心思想其实非常简单，就像我们在玩 RPG 游戏时，会**在脑海中预演未来几秒的情况**：“如果我现在冲上去（动作），虽然能打出高伤害（收益），但因为没有防御技能（状态），会被 BOSS 秒杀（代价）。所以最好先开防御（决策），等 BOSS 技能放完了再打。”

在我们的哨兵系统中，这个“脑海中的预演过程”就是通过**数学公式**来实现的。下面我们将逐一拆解其中的核心概念。

---

## 1. 三个核心变量：你是谁？你要做什么？环境怎么样？

在数学模型中，我们用三个字母来代表整个世界：

### (1) $x_k$：状态向量 (State Vector) —— “你的属性面板”
代表在第 $k$ 秒（当前时刻），机器人的**身体状况**。
```math
x_k = \begin{bmatrix}
P_k \\ H_k \\ Q_k \\ T^{stay}_k \\ T^{cd}_k
\end{bmatrix}
\begin{aligned}
& \leftarrow \text{当前姿态 (进攻/防御/移动)} \\
& \leftarrow \text{当前血量 (HP)} \\
& \leftarrow \text{当前热量 (Heat)} \\
& \leftarrow \text{姿态已维持时间 (用于判断衰减)} \\
& \leftarrow \text{切换冷却时间 (CD)}
\end{aligned}
```

### (2) $u_k$：控制输入 (Control Input) —— “你的手柄按键”
代表你在第 $k$ 秒决定**做什么动作**。
*   $u_k \in \{ \text{进攻}, \text{防御}, \text{移动} \}$
*   注意：你虽然想切姿态，但不一定能成功（如果 CD 没转好），这在转移方程里体现。

### (3) $d_k$：外部扰动 (Disturbance) —— “敌人的行动”
这是**最关键**的部分。因为敌人怎么动我们控制不了，只能预测，所以叫“扰动”。
```math
d_k = \begin{bmatrix}
D_{in}(k) \\ Q_{req}(k) \\ M_{req}(k)
\end{bmatrix}
\begin{aligned}
& \leftarrow \text{预测受到的伤害 (DPS)} \\
& \leftarrow \text{预测你需要开火的热量 (Fire Demand)} \\
& \leftarrow \text{预测你需要跑多快 (Mobility Demand)}
\end{aligned}
```

#### **这三个扰动值是怎么预测出来的？**
我们通过一个简单的**内部预测器 (Internal Predictor)**，根据视觉和导航系统提供的**瞬时观测值 (Observation)** 转换而来：

1.  **预测受到的伤害 ($D_{in}$)**:
    *   **输入**: 视觉系统是否看到敌人 (`enemy_visible`)，敌人距离 (`enemy_dist`)。
    *   **逻辑**:
        *   如果 **看到敌人** 且 **距离 < 3m** (贴脸)：预测 $D_{in} = 200$ (假设敌人会爆发输出)。
        *   如果 **看到敌人** 且 **距离 > 8m** (远程)：预测 $D_{in} = 50$ (假设敌人命中率一般)。
        *   如果 **没看到敌人**：预测 $D_{in} = 0$ (安全)。

2.  **预测你需要开火的热量 ($Q_{req}$)**:
    *   **输入**: 自瞄系统是否锁定 (`is_aim_locked`)。
    *   **逻辑**:
        *   如果 **已锁定**：预测 $Q_{req} = 300$ (假设你要全速射击)。
        *   如果 **未锁定**：预测 $Q_{req} = 0$ (不浪费子弹)。

3.  **预测你需要跑多快 ($M_{req}$)**:
    *   **输入**: 导航目标点距离 (`target_distance`)。
    *   **逻辑**:
        *   距离越远，需求越高。
        *   公式：$M_{req} = \min(1.0, \frac{\text{target\_distance}}{20.0})$。即距离 20米以上时需求拉满。

---

## 2. 核心公式：状态转移方程 (State Transition Equation) （预测）

这是 MPC 的灵魂。它回答了一个问题：**“如果我现在是状态 $x_k$，环境是 $d_k$，我做了动作 $u_k$，那么下一刻 $x_{k+1}$ 会变成什么样？”**

数学表达为：
```math
 x_{k+1} = f(x_k, u_k, d_k) 
```

我们把它拆解成具体的物理过程：

### (1) 姿态更新逻辑 (CD 锁)
首先判断能不能切姿态。
*   **如果** $T^{cd}_k \le 0$ （CD 转好了）：
    *   $P_{k+1} = u_k$ （姿态变为你想要的）
    *   $T^{stay}_{k+1} = 0$ （维持时间重置）
    *   $T^{cd}_{k+1} = 5.0$ （进入 5 秒冷却）
*   **否则** （CD 没好）：
    *   $P_{k+1} = P_k$ （姿态强制保持不变，无视你的 $u_k$）
    *   $T^{stay}_{k+1} = T^{stay}_k + \Delta t$ （维持时间累加）
    *   $T^{cd}_{k+1} = T^{cd}_k - \Delta t$ （冷却时间倒数）

### (2) 血量预测方程 ($H_{k+1}$)
下一刻血量 = 当前血量 - ( 受到伤害 $\times$ **防御系数** )
```math 
H_{k+1} = H_k - D_{in}(k) \cdot \beta(P_{k+1}, T^{stay}_{k+1}) \cdot \Delta t 
```

这里的 $\beta$ 是**防御系数**，它是一个动态变化的数值：
*   **防御姿态**：$\beta = 0.5$ （只受 50% 伤害）。
*   **防御姿态 (衰减)**：如果 $T^{stay} > 180$，则 $\beta = 0.75$ （效果变差，受 75% 伤害）。
*   **其他姿态**：$\beta = 1.25$ （受 125% 伤害，易伤）。

### (3) 热量预测方程 ($Q_{k+1}$)
下一刻热量 = 当前热量 + 开火增加 - **自然冷却**
```math
 Q_{k+1} = Q_k + Q_{req}(k) \cdot \Delta t - \text{BaseCool} \cdot \alpha(P_{k+1}, T^{stay}_{k+1}) \cdot \Delta t 
```

这里的 $\alpha$ 是**冷却倍率**：
*   **进攻姿态**：$\alpha = 3.0$ （3 倍冷却）。
*   **进攻姿态 (衰减)**：如果 $T^{stay} > 180$，则 $\alpha = 2.0$。
*   **其他姿态**：$\alpha = 0.33$ （1/3 冷却）。

---

## 3. 怎么做决策？(代价函数 $J$)

有了上面的预测公式，MPC 就会在脑子里把**所有可能的动作**都模拟一遍，并计算出每个动作的总代价 $J$。代价越小越好。

**代价函数 $J$ 的具体形式**：
```math
 J = \sum_{k=0}^{N} \left( J_{\text{survival}} + J_{\text{missed}} + J_{\text{mobility}} + J_{\text{degrade}} \right) 
```

这四项具体是怎么算的？**它们通过状态转移方程预测出的 $x_{k+1}$ 来计算**：

### (1) 生存代价 ($J_{\text{survival}}$) —— “别死！”
```math
 J_{\text{survival}} = w_{hp} \cdot (H_k - H_{k+1}) \cdot \left( 1 + \frac{H_{max}}{H_k} \right) 
```
*   **联系**：利用状态转移方程算出的 $H_{k+1}$ (下一刻血量)。
*   **含义**：掉血越多，代价越大。而且 **$H_k$ (当前血量) 越低，代价呈指数级暴增**。这迫使 MPC 在残血时极度厌恶任何伤害，哪怕一点点。

### (2) 错失开火代价 ($J_{\text{missed}}$) —— “别哑火！”
```math 
J_{\text{missed}} = w_{fire} \cdot \max(0, \quad Q_{req}(k) \cdot \Delta t - \text{ActualFire}) 
```
*   **联系**：利用状态转移方程算出的 $Q_{k+1}$ 过程中的实际开火量。
*   **含义**：如果我想打 100 热量的子弹 ($Q_{req}$)，但因为热量满了只打出了 20 ($\text{ActualFire}$)，那么我就亏了 80 的输出。这迫使 MPC 在热量高时切进攻姿态（提高冷却上限）。

### (3) 机动性风险代价 ($J_{\text{mobility}}$) —— “别跑不动！”
```math 
J_{\text{mobility}} = w_{mob} \cdot M_{req}(k) \cdot (1.5 - \gamma(P_{k+1})) 
```
*   **联系**：利用状态转移方程中的功率系数 $\gamma$。
*   **含义**：如果我要跑 ($M_{req}$ 高)，但当前姿态的功率系数 $\gamma$ 很低 (比如防御姿态只有 0.5)，那么代价就很大。这迫使 MPC 在长距离奔袭时切移动姿态。

### (4) 衰减惩罚 ($J_{\text{degrade}}$) —— “别超时！”
```math
 J_{\text{degrade}} = \begin{cases} 500, & \text{if } T^{stay}_{k+1} > 180 \\ 0, & \text{else} \end{cases} 
 ```
*   **联系**：利用状态转移方程算出的 $T^{stay}_{k+1}$。
*   **含义**：一旦预测到未来某时刻维持时间超过 180s，直接加一个巨大的罚分。这迫使 MPC 在超时前强制切换。

### 总结
1.  **预测器**把传感器数据变成 $d_k$。
2.  **状态转移方程**拿着 $d_k$ 和 $u_k$，算出了未来的 $x_{k+1}$ (血量、热量等)。
3.  **代价函数**拿着未来的 $x_{k+1}$，给这个未来打分。
4.  MPC 选择**分数最高**的那个未来，对应的动作就是现在的决策。

---

## 4. 姿态系统模拟器（`sentry_simulator.py`）

该模拟器用于在近似赛场环境下评估哨兵姿态切换系统。它并不改变 MPC 的可观测输入（MPC 不知道敌方血量），但会在仿真层面结算命中、扣血与复活/重置。

### 快速开始

1) 无限时间可视化（死亡后自动重置并重新开始）：
```bash
python sentry_simulator.py
```

2) 固定时长 + 可视化：
```bash
python sentry_simulator.py --time 60
```

3) 固定时长 + 无可视化（用于批处理）：
```bash
python sentry_simulator.py --no-viz --time 60
```

4) 死亡竞赛（每轮直到哨兵或敌方死亡）：
```bash
python sentry_simulator.py --duel 100 --seed 0 --no-viz --duel-quiet
```

5) 输出对抗统计数据与图表：
```bash
python sentry_simulator.py --duel 1000 --seed 0 --no-viz --duel-quiet \
  --duel-csv duel_results_1000.csv --duel-plot duel_summary_1000.png
```

### 主要机制（仿真层）

- **姿态 CD**：5 秒内不能切换，模拟器强制拒绝；对抗统计中记录 `cooldown_blocked` 和 `illegal_switch`。
- **姿态弱化**：单姿态持续时间超过 180s 触发弱化倍率。
- **热量与锁枪**：按 10Hz 冷却结算；热量超过上限进入锁枪，超过上限+100 进入永久锁枪。
- **底盘功率/缓冲能量**：缓冲能量耗尽且超功率时断电 5s。
- **移动**：非移动姿态仍可移动，但速度更慢；最低功率按 100W 处理。
- **死亡逻辑**：
  - 时间仿真模式：哨兵死亡立即 `reset()` 并重新开始一轮（时间与日志清零）。
  - 对抗模式：哨兵或敌方死亡即结束该轮。

### 主要参数含义

`SimConfig`（场地与仿真节奏）：
- `dt`: 仿真步长（秒），默认 0.1。
- `total_time`: 时间仿真总时长（秒），0 表示无限。
- `seed`: 随机种子（负数则自动随机）。
- `field_w/field_h`: 场地长宽（米）。
- `sensor_range`: 视野检测距离（米）。
- `lock_range`: 自瞄锁定距离（米）。
- `enemy_speed`: 敌方移动速度（m/s）。
- `enemy_turn_period`: 敌方改变方向的周期（秒）。
- `sentry_speed`: 哨兵基准移动速度（m/s）。
- `waypoint_radius`: 到达目标点判定半径（米）。
- `history_len`: 可视化历史曲线保留长度，0 表示不裁剪。

`SentryParams`（哨兵/敌方参数）：
- `max_hp`: 哨兵最大血量。
- `heat_limit`: 哨兵热量上限。
- `base_cooling`: 基础冷却速率（/s）。
- `buffer_max`: 缓冲能量上限。
- `power_limit`: 底盘功率上限（W）。
- `switch_cd`: 姿态切换冷却（秒）。
- `degrade_limit`: 姿态弱化阈值（秒）。
- `heat_per_shot`: 17mm 单发热量（默认 10）。
- `heat_per_sec_lock`: 超热锁枪阈值增量（默认 +100）。
- `enemy_max_hp`: 敌方最大血量。

### 可视化界面说明

右侧子图依次为：
1) **血量/热量曲线**（含敌方血量）。
2) **缓冲能量/功率需求/功率上限**。
3) **姿态累计时长曲线**（进攻/防御/移动）。

左侧为战场示意图，包含哨兵、敌方、目标点及增益区域；图中会显示当前姿态与原因（中文）。

### 对抗统计输出

对抗模式会输出：
- 胜负统计（击杀、被击杀、KD）
- 平均轮次时长、击杀/被击杀耗时
- 平均切姿态次数与频率
- 姿态占比均值
- 锁枪时间、断电时间、平均热量

可选导出：
- `--duel-csv`：每轮详细数据（用于论文/统计分析）。
- `--duel-plot`：自动生成统计图（PNG）。
